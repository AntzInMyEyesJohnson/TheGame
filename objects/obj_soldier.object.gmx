<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_soldier_idle</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>obj_enemy_parent</parentName>
  <maskName>spr_soldier_idle</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///init enemy
GetEnemyTimers();
InitializeScreenFreezeVariables();
hitby_list = ds_list_create();//create hitbox ds list
hitby_list_timer = -1;
state = 'idle';
move_speed = 0;
accel = 20/room_speed;
decel = .85;
toughness = 2;
enemy_health_max = 3;
enemy_health = enemy_health_max;
melee_damage = 1;
image_speed = 0;
blood_type = 0;
death_alarm_time = round(random_range(room_speed*1.5,room_speed*2));
scale_factor = 1;
shot_count = 0;
moving = false;
moving_start = 0;
moving_length = 0;
event_inherited();

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///destroy list and draw to surface
if (ds_exists(hitby_list,ds_type_list)){
    ds_list_destroy(hitby_list);
}

//set death depth
depth = -(y+8);
//draw to surface
surface_set_target(obj_surface.surf);
    draw_sprite_ext(sprite_index,image_index,x,y,image_xscale,image_yscale,0,c_gray,image_alpha)
surface_reset_target();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///run state and collisions with grid
depth = -y;
//screen freeze check
if (ScreenFreezeCheck()){exit;}

//state machine
switch(state){
    case 'idle':
        if (idle_timer == 0){
            idle_max_time = irandom_range(15,60);
        }
        //automatically set move speed max to 1/12 pixels per second
        move_speed = 15/room_speed;
        //decelerate
        if (hspd != 0){hspd *= decel;}
        if (vspd != 0){vspd *= decel;}
        //sprite change
        sprite_index = spr_soldier_idle;
        img_spd = 0.1;
        
        
        if (IHaveLineOfSightTo(obj_player) and idle_timer &gt;= idle_max_time){//and IAmFacingTowards(obj_player)){
            ResetStateTimers();
            state = 'alert';
        } 
    break;
    case 'alert':
        move_speed = 60/room_speed;//60/sec
        //decelerate
        if (hspd != 0 and !moving){hspd *= decel;}
        if (vspd != 0 and !moving){vspd *= decel;}
        //sprite shit
        sprite_index = spr_soldier_move;
        img_spd = 0;
        
        //set max time spent in alert state
        if (alert_timer == 0){
            alert_max_time = irandom_range(20,100);
        }
        
        //move towards player on occassion
        var move_chance = 5;
        if (irandom(move_chance) == move_chance){
            if (IHaveLineOfSightTo(obj_player)){
                player_dir = point_direction(x,y,obj_player.x,obj_player.y);
                move_dir = irandom_range(player_dir-60,player_dir+60);
            }else {
                move_dir = irandom(360);
            }
            moving_start = alert_timer;
            moving_length = 15;
            moving = true;
        }
        
        if (moving){
            //bounce in the direction that was established in alert state
            hspd += lengthdir_x(accel,move_dir);
            vspd += lengthdir_y(accel,move_dir);
            if (alert_timer &gt;= moving_start+moving_length){
                moving = false;
            }
        }
        
        //shoot at player either when shoot chance happens or end of alert
        var shoot_chance = 10;
        //if player is in sight
        if (IHaveLineOfSightTo(obj_player) and (irandom(shoot_chance) == shoot_chance or alert_timer &gt;= alert_max_time)){ 
            player_dir = point_direction(obj_player.x,obj_player.y,x,y);
            charge_alarm_time = 30;
            charge_alarm = charge_alarm_time;
            //shoot towards player
            attack_direction = point_direction(x,y,obj_player.x,obj_player.y);
            moving = false;
            state = 'charge';
        }   
    break;
    case 'charge':
        move_speed = 30/room_speed;
        //decelerate
        if (hspd != 0){hspd *= decel;}
        if (vspd != 0){vspd *= decel;}
        //sprite change
        sprite_index = spr_soldier_charge;
        img_spd = 0;
        //animate attack with special script
        image_index = AnimateToAlarm(charge_alarm_time,charge_alarm);
        
        //only shoot in attack direction once so all three shots go to same spot
        if(shot_count = 0){
            //set the shot direction on occasion so accuracy is somewhat decent
            var attack_chance = 10;
            if (irandom(attack_chance) == attack_chance){
                //shoot towards player
                attack_direction = point_direction(x,y,obj_player.x,obj_player.y);
            }
            
            //set attack direction in case attack chance never triggers
            if (charge_alarm == round(charge_alarm_time/2)){
                //shoot towards player
                attack_direction = point_direction(x,y,obj_player.x,obj_player.y);
            }
        }
        
        if (charge_alarm &lt; 0){
            //add innaccuracy
            attack_direction = irandom_range(attack_direction-5,attack_direction+5);
            //set attack alarm
            attack_alarm_time = 10;
            attack_alarm = attack_alarm_time;
            state = 'attack';
        }
    break;
    case 'attack':
        move_speed = 15/room_speed;
        //decelerate
        if (hspd != 0){hspd *= decel;}
        if (vspd != 0){vspd *= decel;}
        //sprite change
        sprite_index = spr_soldier_attack;
        img_spd = 0;
        //animate attack with special script
        image_index = AnimateToAlarm(attack_alarm_time,attack_alarm);
        //shoot projectile
        if (attack_alarm == round(attack_alarm_time-1)){
            //shoot towards attack direction
            var projectile = instance_create(x+lengthdir_x(6,attack_direction),y+lengthdir_y(6,attack_direction),obj_enemy_projectile);
            projectile.creator = self.id;
            
            //add to shot count
            shot_count++;
            
            //recoil after shot
            move_speed = 120/room_speed;
            hspd = lengthdir_x(120/room_speed,attack_direction-180);
            vspd = lengthdir_y(120/room_speed,attack_direction-180);
            
            //TODO add shot sound
            //###################
        }
        
        if (attack_alarm &lt; 0){
            if (shot_count &gt;= 3){
                //reset shot count
                shot_count = 0;
                //reset_timers
                ResetStateTimers();
                state = 'idle';
            } else {
                charge_alarm_time = 10;
                charge_alarm = charge_alarm_time;
                state = 'charge'
            }
        }            
    break;
    case 'hit':
        EnemyHitState(spr_soldier_hit,global.pt_blood,'alert'); 
    break;
    case 'death':
        //decelerate
        move_speed *= decel;
        death_speed *= decel;
        hspd *= decel;
        vspd *= decel;
        if (death_alarm == round(death_alarm_time-1)) {
            //set direction
            hit_direction = point_direction(obj_player.x,obj_player.y,x,y);
            //init blood
            CreateBlood(global.pt_blood,hit_direction,part_amount);
            if (death_by_slash == true){
                sprite_index = spr_soldier_deathbyslash;
                CreateDebris(spr_soldier_death_splat,true,part_amount/2,hit_direction,scale_factor,spr_axman_shadow,true);
                death_by_slash = false;
            } else if (death_by_slash == false){
                sprite_index = spr_soldier_deathnormal;
            }       
        }else if (death_alarm == round(death_alarm_time-2)){
            //continue blood
            CreateBlood(global.pt_blood,hit_direction,part_amount);
        }
        img_spd = 0;
        //animate death with special script
        image_index = AnimateToAlarm(death_alarm_time,death_alarm); 
        //destroy object
        if (death_alarm &lt; 0){
            image_index = image_number-1;
            ChanceToDropItem(25);
            instance_destroy();
        }
    break;       
}
IncrementEnemyTimers();

/* Facing */
if (hspd != 0){
    if (state == 'charge' or state == 'attack'){
        if (round(attack_direction/180) == 1){image_xscale = -1;}
        else {image_xscale = 1;}
    }else if(state == 'hit' or state == 'death'){
        image_xscale = -sign(hspd);
    } else {
        image_xscale = sign(hspd);
    }
}

image_xscale = sign(image_xscale)*scale_factor;
image_yscale = sign(image_yscale)*scale_factor;



EnemyHitByProjectile();

EnemyCollisionWithWallGrid();

HitbyListManagement();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///destroy list
if (ds_exists(hitby_list,ds_type_list)){
    ds_list_destroy(hitby_list);
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///draw ninja
draw_sprite_ext(spr_ninja_shadow,0,x,y,image_xscale,image_yscale,0,c_white,1);
draw_self();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>



