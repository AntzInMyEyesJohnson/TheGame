<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_slime_chase</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>obj_melee_parent</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///init enemy
GetEnemyTimers();
InitializeScreenFreezeVariables();
hitby_list = ds_list_create();//create hitbox ds list
hitby_list_timer = -1;
if (IHaveLineOfSightTo(obj_player) and IAmFacingTowards(obj_player)){
    ResetStateTimers();
    state = 'chase';
} else {
    ResetStateTimers();
    state = choose('idle','wander');
}
move_speed = 40/room_speed;
accel = 10/room_speed;
decel = .85;
toughness = 1;
enemy_health_max = 1;
enemy_health = enemy_health_max;
melee_damage = 1;
image_speed = 0;
blood_type = 0;
scale_factor = .5;
direction = irandom(360);
death_alarm_time = round(room_speed*.5);

if (grid_place_meeting(x,y,0)){
    instance_destroy();
}

event_inherited();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///destroy list
///destroy list
if (ds_exists(hitby_list,ds_type_list)){
    ds_list_destroy(hitby_list);
}
depth = -(y);
//draw to surface
surface_set_target(obj_surface.surf);
    draw_sprite_ext(spr_slime_splatter,0,x,y-4,image_xscale*scale_factor,image_yscale*scale_factor,choose(0,180),c_gray,image_alpha)
surface_reset_target();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///run state and collisions with grid
//set depth
depth = -y;
//screen freeze check
if (ScreenFreezeCheck()){exit;}

//time manipulation check
//if (TimeStopCheck()){exit;}

//state machine
switch(state){
    case 'idle':
        move_speed *= 1/10;
        sprite_index = spr_slime_chase;
        image_speed = .1;
        if (idle_timer == 0){
            idle_max_time = round(random_range(room_speed*.5, room_speed*2.5));
        }
        //decelerate
        if (hspd != 0){hspd *= decel;}
        if (vspd != 0){vspd *= decel;}
        if (idle_timer &gt; idle_max_time){
            ResetStateTimers();
            state = 'wander';
        } else if (idle_timer &gt; idle_max_time/2){
            if (IHaveLineOfSightTo(obj_player) and IAmFacingTowards(obj_player)){
                ResetStateTimers();
                state = 'chase';
            }
        }
    break;
    case 'wander':
        sprite_index = spr_slime_chase;
        image_speed = .15;
        move_speed = 40/room_speed;//60/sec
        if (wander_timer == 0){
            wander_max_time = round(random_range(room_speed*1, room_speed*3));
            move_dir = irandom(360);
        }
        //accelerate
        hspd += lengthdir_x(accel,move_dir);
        vspd += lengthdir_y(accel,move_dir);
        if (wander_timer &gt; wander_max_time){
            ResetStateTimers();
            state = 'idle';
        } else if (wander_timer &gt; wander_max_time/2){
            if (IHaveLineOfSightTo(obj_player) and
                IAmFacingTowards(obj_player)){
                ResetStateTimers();
                state = 'chase';
            }
        }
    break;
    case 'chase':
        sprite_index = spr_slime_chase;
        image_speed = .25;
        move_speed = 50/room_speed;//90/sec
        if (chase_timer == 0){
            chase_max_time = round(random_range(room_speed*2, room_speed*3));
            move_dir = point_direction(x,y,obj_player.x,obj_player.y);
        }
        //how often enemy looks for player while wandering and chasing and what not
        check_chance = 8;
        if (irandom(check_chance) == check_chance){
            if (IHaveLineOfSightTo(obj_player) and IAmFacingTowards(obj_player)){
                move_dir = point_direction(x,y,obj_player.x,obj_player.y);
            }
        }
        //accelerate
        hspd += lengthdir_x(accel,move_dir);
        vspd += lengthdir_y(accel,move_dir);
        if (chase_timer &gt; chase_max_time){
            ResetStateTimers();
            state = choose('wander','idle');
        }
    break;
    case 'attack':
        //decelerate
        hspd *= decel;
        vspd *= decel;
        move_speed *= 1/10;
        sprite_index = spr_slime_attack;
        image_speed = 0;
        //animate attack with special script
        image_index = AnimateToAlarm(attack_alarm_time,attack_alarm);
        if (attack_alarm == round(attack_alarm_time-1)){
            var projectile = instance_create(x,y,obj_enemy_projectile_melee);
            projectile.creator = self.id;
        }
        if (attack_alarm &lt; 0){
            //reset_timers
            ResetStateTimers();
            state = choose('idle','wander');
        }           
    break;
    case 'hit':
        //decelerate
        move_speed *= decel;
        hspd *= decel;
        vspd *= decel;
        //sprite change
        sprite_index = spr_slime_hit;
        img_spd = 0;
        if (hit_timer == 0){
            hit_max_time = 22;
            //set image_index green hit index
            image_index = 0;
            //set direction
            hit_direction = point_direction(obj_player.x,obj_player.y,x,y);
            //init blood
            CreateBlood(global.pt_slime,hit_direction,round(part_amount/2));
        }else if (hit_timer == 1){
            //continue blood
            CreateBlood(global.pt_slime,hit_direction,round(part_amount/2));
        }
        //set index to white index
        if (hit_timer == 2){
            image_index = 1;
        }
        //set index to hit index after white index
        if (hit_timer == 5){
            image_index = 2;
        }
        //set index to hit index after white index
        if (hit_timer == 13){
            image_index = 3;
        }
        //exit hit state 
        if (hit_timer &gt;= hit_max_time){
            if (IHaveLineOfSightTo(obj_player) and IAmFacingTowards(obj_player)){
                ResetStateTimers();
                state = 'chase';
            } else {
                ResetStateTimers();
                state = choose('idle','wander');
            }
        }
    break;
    case 'death':
        //decelerate
        move_speed *= 1/10;
        death_speed *= decel;
        hspd *= decel;
        vspd *= decel;
        //sprite change
        sprite_index = spr_slime_chase;
        image_speed = 0;
        if (death_alarm == round(death_alarm_time - 1)){
            //set direction
            hit_direction = point_direction(obj_player.x,obj_player.y,x,y);
            //init blood
            CreateBlood(global.pt_slime,hit_direction,round(part_amount/2));
        }else if (death_alarm == round(death_alarm_time - 2)){
            //continue blood
            CreateBlood(global.pt_slime,hit_direction,round(part_amount/2));
        }
        //animate death with special script
        image_index = AnimateToAlarm(death_alarm_time,death_alarm);
        //destroy object
        if (death_alarm &lt; 0){
            move_speed = 0;
            ChanceToDropItem(30);
            //create two tiny slimes
            instance_destroy();
        }
    break;        
}
IncrementEnemyTimers();

/* Facing */
if (hspd != 0){
    if (state == 'hit' or state == 'death'){
        image_xscale = -sign(hspd);
    } else {
        image_xscale = sign(hspd);
    }
}

/* Scale change for slime*/
image_xscale = sign(image_xscale)*scale_factor;
image_yscale = sign(image_yscale)*scale_factor;

if (instance_exists(obj_player)){
    attacking_direction = point_direction(x,y,obj_player.x,obj_player.y);
}
attacking_player = instance_place(x+lengthdir_x(4,attacking_direction),y+lengthdir_y(4,attacking_direction),obj_player);

if (attacking_player and state != 'hit' and state != 'death'){
    if (attack_alarm &lt; 0){
        attack_alarm_time = 30;
        attack_alarm = attack_alarm_time;
        state = 'attack';
    }
}    

EnemyHitByProjectile();

EnemyCollisionWithWallGrid();

HitbyListManagement();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///destroy list
if (ds_exists(hitby_list,ds_type_list)){
    ds_list_destroy(hitby_list);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>



